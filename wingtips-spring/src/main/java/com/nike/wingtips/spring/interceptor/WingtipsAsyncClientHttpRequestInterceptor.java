package com.nike.wingtips.spring.interceptor;

import static com.nike.wingtips.spring.util.WingtipsSpringUtil.getRequestMethodAsString;
import static com.nike.wingtips.spring.util.WingtipsSpringUtil.propagateTracingHeaders;
import static com.nike.wingtips.util.AsyncWingtipsHelperJava7.runnableWithTracing;
import static com.nike.wingtips.util.AsyncWingtipsHelperJava7.unlinkTracingFromCurrentThread;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.AsyncClientHttpRequestExecution;
import org.springframework.http.client.AsyncClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureCallback;
import org.springframework.web.client.AsyncRestTemplate;

import com.nike.wingtips.Span;
import com.nike.wingtips.Tracer;
import com.nike.wingtips.http.HttpRequestTracingUtils;
import com.nike.wingtips.spring.interceptor.tag.SpringHttpClientTagAdapter;
import com.nike.wingtips.spring.util.HttpRequestWrapperWithModifiableHeaders;
import com.nike.wingtips.tags.HttpTagStrategy;
import com.nike.wingtips.tags.OpenTracingTagStrategy;
import com.nike.wingtips.util.TracingState;

/**
 * A {@link AsyncClientHttpRequestInterceptor} which propagates Wingtips tracing information on a downstream {@link
 * AsyncRestTemplate} call's request headers, with an option to surround downstream calls in a subspan. The subspan option
 * defaults to on and is highly recommended since the subspans will provide you with timing info for your downstream
 * calls separate from any parent span that may be active at the time this interceptor executes.
 *
 * <p>If the subspan option is enabled but there's no current span on the current thread when this interceptor executes,
 * then a new root span (new trace) will be created rather than a subspan. In either case the newly created span will
 * have a {@link Span#getSpanPurpose()} of {@link Span.SpanPurpose#CLIENT} since this interceptor is for a client call.
 * The {@link Span#getSpanName()} for the newly created span will be generated by {@link
 * #getSubspanSpanName(HttpRequest)} - override that method if you want a different span naming format.
 *
 * <p>Note that if you have the subspan option turned off then this interceptor will propagate the {@link
 * Tracer#getCurrentSpan()}'s tracing info downstream if it's available, but will do nothing if no current span exists
 * on the current thread when this interceptor executes as there's no tracing info to propagate. Turning on the
 * subspan option mitigates this as it guarantees there will be a span to propagate.
 *
 * <p>Since this interceptor works by setting request headers and we may be passed an immutable request, we wrap
 * the request in a {@link HttpRequestWrapperWithModifiableHeaders} to guarantee that the request headers are mutable.
 * Keep in mind that this will make the headers mutable for any interceptors that execute after this one.
 *
 * @author Nic Munroe
 */
@SuppressWarnings("WeakerAccess")
public class WingtipsAsyncClientHttpRequestInterceptor implements AsyncClientHttpRequestInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(WingtipsAsyncClientHttpRequestInterceptor.class);
    
    /**
     * The default implementation of this class. Since this class is thread-safe you can reuse this rather than creating
     * a new object.
     */
    public static final WingtipsAsyncClientHttpRequestInterceptor DEFAULT_IMPL =
            new WingtipsAsyncClientHttpRequestInterceptor();

    /**
     * If this is true then all downstream calls that this interceptor intercepts will be surrounded by a
     * subspan which will be started immediately before the call and completed as soon as the call completes.
     */
    protected final boolean surroundCallsWithSubspan;

    protected final HttpTagStrategy<HttpRequest, ClientHttpResponse> tagStrategy;
    
    /**
     * Default constructor - sets {@link #surroundCallsWithSubspan} to true.
     */
    public WingtipsAsyncClientHttpRequestInterceptor() {
        this(true);
    }

    /**
     * Constructor that lets you choose whether downstream calls will be surrounded with a subspan.
     *
     * @param surroundCallsWithSubspan pass in true to have downstream calls surrounded with a new span, false to only
     * propagate the current span's info downstream (no subspan).
     */
    public WingtipsAsyncClientHttpRequestInterceptor(boolean surroundCallsWithSubspan) {
        this(surroundCallsWithSubspan, new OpenTracingTagStrategy<HttpRequest, ClientHttpResponse>(new SpringHttpClientTagAdapter()));
    }
    
    /**
     * Constuctor that lets you define whether downstream calls will be surrounded with a subspan and provide
     * a different span tag strategy. 
     * @param surroundCallsWithSubspan pass in true to have downstream calls surrounded with a new span, false to only
     * @param tagStrategy set the strategy by which to tag the span
     */
    public WingtipsAsyncClientHttpRequestInterceptor(boolean surroundCallsWithSubspan, 
            HttpTagStrategy<HttpRequest, ClientHttpResponse> tagStrategy) {
        this.surroundCallsWithSubspan = surroundCallsWithSubspan;
        this.tagStrategy = tagStrategy;
    }

    @Override
    @SuppressWarnings("deprecation")
    public ListenableFuture<ClientHttpResponse> intercept(
        HttpRequest request, byte[] body, AsyncClientHttpRequestExecution execution
    ) throws IOException {
        HttpRequest wrapperRequest = new HttpRequestWrapperWithModifiableHeaders(request);

        if (surroundCallsWithSubspan) {
            return createAsyncSubSpanAndExecute(wrapperRequest, body, execution);
        }
        return propagateTracingHeadersAndExecute(wrapperRequest, body, execution);
    }
    
    public ListenableFuture<ClientHttpResponse> propagateTracingHeadersAndExecute(
            HttpRequest request, byte[] body, AsyncClientHttpRequestExecution execution
        ) throws IOException {
        // Whether we created a subspan or not we want to add the tracing headers with the current span's info.
        propagateTracingHeaders(request, Tracer.getInstance().getCurrentSpan());

        // Execute the request/interceptor chain, and add the callback to finish the subspan (if one exists).
        return execution.executeAsync(request, body);
    }
    
    public ListenableFuture<ClientHttpResponse> createAsyncSubSpanAndExecute(
            HttpRequest request, byte[] body, AsyncClientHttpRequestExecution execution
            ) throws IOException {

        Tracer tracer = Tracer.getInstance();

        // Handle subspan stuff
        TracingState originalThreadInfo = TracingState.getCurrentThreadTracingState();

        // This will start a new trace if necessary, or a subspan if a trace is already in progress.
        tracer.startSpanInCurrentContext(getSubspanSpanName(request), Span.SpanPurpose.CLIENT);

        // Tag the new span with request meta data.  Response meta data is tagged by the finisher.
        tagSpanWithRequestAttributes(tracer.getCurrentSpan(), request);
        
        // Create the callback that will complete the subspan when the request finishes.
        SpanAroundAsyncCallFinisher subspanFinisher = 
                new SpanAroundAsyncCallFinisher(TracingState.getCurrentThreadTracingState(), tagStrategy);

        try {
            ListenableFuture<ClientHttpResponse> result = propagateTracingHeadersAndExecute(request, body, execution);
            result.addCallback(subspanFinisher);
            return result;
        }
        catch(Throwable t) {
            // Something went wrong in the execution.executeAsync(...) call so we complete the subspan now
            subspanFinisher.tagCurrentSpanAsErrdAndFinish(t);
            throw t;
        }
        finally {
            // Reset back to the original tracing state that was on this thread when this method began
            unlinkTracingFromCurrentThread(originalThreadInfo);
        }
    }

    /**
     * Returns the name that should be used for the subspan surrounding the call. Defaults to {@code
     * asyncresttemplate_downstream_call-[HTTP_METHOD]_[REQUEST_URI]} with any query string stripped, e.g. for a GET
     * call to https://foo.bar/baz?stuff=things, this would return {@code
     * "asyncresttemplate_downstream_call-GET_https://foo.bar/baz"}. You can override this method to return something
     * else if you want a different subspan name format.
     *
     * @param request The request that is about to be executed.
     * @return The name that should be used for the subspan surrounding the call.
     */
    protected String getSubspanSpanName(HttpRequest request) {
        return HttpRequestTracingUtils.getSubspanSpanNameForHttpRequest(
            "asyncresttemplate_downstream_call", getRequestMethodAsString(request.getMethod()), request.getURI().toString()
        );
    }
    
    /**
     * Broken out as a separate method so we can surround it in a try{} to ensure we don't break the overall
     * span handling with exceptions from the {@code tagStrategy}.
     * @param span The span to be tagged
     * @param requestObj The request context to use for tag values
     */
    private void tagSpanWithRequestAttributes(Span span, HttpRequest requestObj) {
        try {
            tagStrategy.tagSpanWithRequestAttributes(span, requestObj);
        } catch(Throwable taggingException) {
            logger.warn("Unable to tag span with request attributes", taggingException);
        }
    }
    
    /**
     * A {@link ListenableFutureCallback} that will complete the given {@link TracingState} (e.g. tracing state
     * representing a subspan) when executed. This should be attached as a callback to the result of {@link
     * #intercept(HttpRequest, byte[], AsyncClientHttpRequestExecution)}.
     */
    @SuppressWarnings("WeakerAccess")
    protected static class SpanAroundAsyncCallFinisher implements ListenableFutureCallback<ClientHttpResponse> {

        protected final TracingState spanAroundCallTracingState;
        protected final HttpTagStrategy<HttpRequest, ClientHttpResponse> tagStrategy;

        protected SpanAroundAsyncCallFinisher(TracingState spanAroundCallTracingState, HttpTagStrategy<HttpRequest, ClientHttpResponse> tagStrategy) {
            this.spanAroundCallTracingState = spanAroundCallTracingState;
            this.tagStrategy = tagStrategy;
        }

        @Override
        public void onFailure(Throwable ex) {
            tagCurrentSpanAsErrdAndFinish(ex);
        }

        @Override
        public void onSuccess(ClientHttpResponse result) {
            tagSpanWithResponseAttributesAndFinish(result);
        }

        @SuppressWarnings("deprecation")
        protected void tagSpanWithResponseAttributesAndFinish(final ClientHttpResponse response) {
            if (spanAroundCallTracingState != null) {
                runnableWithTracing(
                        new Runnable() {
                            @Override
                            public void run() {
                                Span span = Tracer.getInstance().getCurrentSpan();
                                // Add the tags from the response
                                tagSpanWithResponseAttributes(span, response);
                                // Span.close() contains the logic we want - if the spanAroundCall was an overall span (new trace)
                                //      then tracer.completeRequestSpan() will be called, otherwise it's a subspan and
                                //      tracer.completeSubSpan() will be called.
                                span.close();
                                
                            }
                            
                            /**
                             * Broken out as a separate method so we can surround it in a try{} to ensure we don't break the overall
                             * span handling with exceptions from the {@code tagStrategy}.
                             * @param span The span to be tagged
                             * @param responseObj The response context to be used for tag values
                             */
                            private void tagSpanWithResponseAttributes(Span span, ClientHttpResponse responseObj) {
                                try {
                                    tagStrategy.tagSpanWithResponseAttributes(span, responseObj);
                                } catch(Throwable taggingException) {
                                    logger.warn("Unable to tag span with response attributes", taggingException);
                                }
                            }
                        },
                        spanAroundCallTracingState
                        ).run();

            }
        }
        
        @SuppressWarnings("deprecation")
        private void tagCurrentSpanAsErrdAndFinish(final Throwable throwable) {
            if (spanAroundCallTracingState != null) {
                runnableWithTracing(
                        new Runnable() {
                            @Override
                            public void run() {
                                Span span = Tracer.getInstance().getCurrentSpan();

                                // Add the tags based on the exception
                                handleErroredRequestTags(span, throwable);

                                // Span.close() contains the logic we want - if the spanAroundCall was an overall span (new trace)
                                //      then tracer.completeRequestSpan() will be called, otherwise it's a subspan and
                                //      tracer.completeSubSpan() will be called.
                                span.close();
                            }
                            
                            /**
                             * Broken out as a separate method so we can surround it in a try{} to ensure we don't break the overall
                             * span handling with exceptions from the {@code tagStrategy}.
                             * @param span The span to be tagged
                             * @param throwable The exception context to use for tag values
                             */
                            private void handleErroredRequestTags(Span span, Throwable throwable) {
                                try {
                                    tagStrategy.handleErroredRequest(span, throwable);
                                } catch(Throwable taggingException) {
                                    logger.warn("Unable to tag errored span with exception", taggingException);
                                }
                            }
                        },
                        spanAroundCallTracingState
                        ).run();
            }
        }
    }

    
}
